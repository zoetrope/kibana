[[getting-started]]
== Kibanaを始めてみよう

Kibanaの<<setup,インストール>>が完了したら、このチュートリアルを通して、Kibanaの主要な機能の最初のハンズオンを経験することができます。
このチュートリアルを終えたときには、次のことができているでしょう。

* Elasticsearchにサンプルのデータを読み込む。
* 少なくとも1つのインデックスパターンを定義する。
* <<discover, Discover>>機能を使って、データを探索する。
* データをグラフィカルに表現するためのいくつかの <<visualize,_可視化_>> をセットアップする。
* <<dashboard,Dashboard>>で可視化を組み立てる。

なお、本セクションの内容は、KibanaとElasticsearchがインストールされて動いているものとします。

[float]
[[tutorial-load-dataset]]
=== 始める前に: サンプルデータの読み込み

本セクションのチュートリアルでは、以下のデータを利用します:

* 適切なフィールドごとにパースされた、ウィリアム・シェイクスピア全集。このデータはここをクリックしてダウンロードしてください:
  https://www.elastic.co/guide/en/kibana/3.0/snippets/shakespeare.json[shakespeare.json].
* ランダムに生成された架空の口座データ。このデータはここをクリックしてダウンロードしてください:
  https://github.com/bly2k/files/blob/master/accounts.zip?raw=true[accounts.zip]
* ランダムに生成されたlogstashのデータ。このデータはここをクリックしてダウンロードしてください:
  https://download.elastic.co/demos/kibana/gettingstarted/logs.jsonl.gz[logstash.jsonl.gz]

データのうち2つは圧縮されています。以下のコマンドを使ってファイルを展開してください:

[source,shell]
unzip accounts.zip
gunzip logs.jsonl.gz

シェイクスピアのデータは、以下のスキーマに従います:

[source,json]
{
    "line_id": INT,
    "play_name": "String",
    "speech_number": INT,
    "line_number": "String",
    "speaker": "String",
    "text_entry": "String",
}

口座のデータは、以下のスキーマに従います:

[source,json]
{
    "account_number": INT,
    "balance": INT,
    "firstname": "String",
    "lastname": "String",
    "age": INT,
    "gender": "M or F",
    "address": "String",
    "employer": "String",
    "email": "String",
    "city": "String",
    "state": "String"
}

logstashのデータのスキーマは異なるたくさんのフィールドを持ちますが、このチュートリアルで利用する主要なものは以下の通りです:

[source,json]
{
    "memory": INT,
    "geo.coordinates": "geo_point"
    "@timestamp": "date"
}

シェイクスピアのデータを投入する前に、フィールドに {ref}/mapping.html[_マッピング_] を設定する必要があります。
マッピングは、インデックスを論理的なグループにドキュメントを分割し、フィールドの特徴を明示します。例えばフィールドの検索性を表す特徴として、 _トークナイズ_ するかどうか、すなわち単語ごとに分割されるかどうかを指定することができます。

シェイクスピアのデータに、以下のコマンドでマッピングを設定します:

[source,shell]
curl -XPUT http://localhost:9200/shakespeare -d '
{
 "mappings" : {
  "_default_" : {
   "properties" : {
    "speaker" : {"type": "string", "index" : "not_analyzed" },
    "play_name" : {"type": "string", "index" : "not_analyzed" },
    "line_id" : { "type" : "integer" },
    "speech_number" : { "type" : "integer" }
   }
  }
 }
}
';

このマッピングは、データに対して以下の性質を指定しています:

* _speaker_ フィールドは、解析されない文字列です。このフィールドの文字列は、複数の単語で構成されていたとしても、1つの文字列のかたまりとして扱われます。
* _play_name_ フィールドも同じです。
* line_id と speech_number フィールドは整数値になります。

口座データとlogstashのデータは、特定のマッピングを必要としません。
これで、以下のコマンドでElasticsearchにデータを投入する準備ができました:

[source,shell]
curl -XPOST 'localhost:9200/bank/_bulk?pretty' --data-binary @accounts.json
curl -XPOST 'localhost:9200/shakespeare/_bulk?pretty' --data-binary @shakespeare.json
curl -XPOST 'localhost:9200/_bulk?pretty' --data-binary @logstash.json

これらのコマンドは、環境によっては実行するのに少し時間がかかるでしょう。

以下のコマンドで、データの投入の成功を確認しましょう:

[source,shell]
curl 'localhost:9200/_cat/indices?v'

以下のような出力が得られるでしょう:

[source,shell]
health status index               pri rep docs.count docs.deleted store.size pri.store.size
yellow open   bank                  5   1       1000            0    418.2kb        418.2kb
yellow open   shakespeare           5   1     111396            0     17.6mb         17.6mb
yellow open   logstash-2015.05.18   5   1       4631            0     15.6mb         15.6mb
yellow open   logstash-2015.05.19   5   1       4624            0     15.7mb         15.7mb
yellow open   logstash-2015.05.20   5   1       4750            0     16.4mb         16.4mb

[[tutorial-define-index]]
=== インデックスパターンの定義

Elasticsearchにロードされたデータはそれぞれ https://www.elastic.co/guide/en/kibana/current/settings.html#settings-create-pattern[インデックスパターン] を持ちます。
Each set of data loaded to Elasticsearch has an https://www.elastic.co/guide/en/kibana/current/settings.html#settings-create-pattern[index pattern].
前のセクションで、シェイクスピアのデータは `shakespeare` という名前のインデックスを、口座データは `bank` という名前のインデックスを持っています。
In the previous section, the Shakespeare data set has an index named `shakespeare`, and the accounts data set has an index named `bank`.
_インデックスパターン_ は、複数のインデックスにマッチすることのできるワイルドカードを利用することもできます。
An _index pattern_ is a string with optional wildcards that can match multiple indices.
たとえば、よくあるログのユースケースにおいて、典型的なインデックス名はYYYY.MM.DDというフォーマットの日付を含み、5月のインデックスパターンであれば `logstash-2015.05*` のようになります。

本チュートリアルは、先ほど登録した2つのインデックスのどちらにマッチするインデックスパターンでも動きます。
まず、ブラウザを開き `localhost:5601` に移動してください。
*Settings* タブの *Indices* タブをクリックします。
新しいインデックスパターンを定義するために *Add New* をクリックします。
今回のデータは時系列のデータを含まないため *Index contains time-based events* のチェックが外れていることを確認してください。
シェイクスピアのデータのインデックスパターンとして `shakes*` を指定し、 *Create* をクリックしてインデックスパターンを定義します。つづいて `ba*` という名前のインデックスパターンを定義します。

[float]
[[tutorial-discovering]]
=== データの発見

Kibanaのデータ発見機能を見るために *Discover* タブをクリックしてください:

image::images/tutorial-discover.png[]

そのタブのすぐ下に、データを検索するための検索ボックスがあります。
検索には、いろいろな検索条件を作ることのできる {ref}/query-dsl-query-string-query.html#query-string-syntax[query syntax] を使います。
また、検索ボックスの右のボタンをクリックすることで、それらの検索条件を保存したりロードしたりすることができます。

検索ボックスの下には、現在のインデックスパターンがドロップダウンで表示されます。
ドロップダウンから他のパターンを選択することで、インデックスパターンを切り替えることができます。

あなたが興味のあるフィールド名とその値を使って、検索条件を組み立てることができます。
数値フィールドであれば、以上(>)、以下(<)、等しい(=)などの比較演算子を利用することができます。
さらに、AND, OR, NOTなどの論理演算子(すべて大文字)を使って、検索条件を組み合わせることができます。

`ba*` のインデックスパターンを選択して、次の検索条件を検索ボックスに入力してみましょう。

[source,text]
account_number:<100 AND balance:>47500

この検索では、口座番号が0から99の間で、残高が47,500以上のすべての口座を返します。

もし、前セクションのサンプルデータを利用しているのであれば、この検索は口座番号が8, 32, 78, 85, 97の5つの結果を返します。

image::images/tutorial-discover-2.png[]

興味のある特定のフィールドだけを表示したい場合は、インデックスパターンの下に表示されているフィールドにマウスオーバーし、 *Add* ボタンをクリックします。
この例では、 `account_number` フィールドを追加することで、5つのレコードのすべてのテキストが表示されていたものが、5つの口座番号のみが表示されるようになりました:

image::images/tutorial-discover-3.png[]

[[tutorial-visualizing]]
=== 可視化: 発見の向こう側

*Visualize* タブから利用できる可視化ツールは、様々な異なる方法でデータのある側面を表示することを可能にします。

開始するためには *Visualize* タブをクリックします:

image::images/tutorial-visualize.png[]


*Pie chart* をクリックし、つづいて *From a new search* をクリックします。
そして `ba*` インデックスパターンを選択してください。

Kibanaの可視化では _bucket_ aggregations と _metric_ aggregations というElasticsearchにおける2つの異なるタイプの {ref}/search-aggregations.html[aggregations] を利用しています。
bucket aggregationは、指定した条件に応じてデータの並び替えをおこないます。
たとえば、口座データでは、口座残高の範囲を決めて、その範囲で分類される合計金額がどれくらいの割合なのかを表示することができます。

以下のような全体の円グラフでは、いずれのbucketもまだ指定されていません。

image::images/tutorial-visualize-pie-1.png[]

*Select buckets type* の一覧から *Split Slices* を選択し、 *Aggregation* のドロップダウンから *Range* を選択します。
*Field* ドロップダウンから *balance* フィールドを選択し、 *Add Range* を4回クリックして数値の範囲を6つにします。
そして、以下の範囲を入力してください:

[source,text]
0            1000
1000         3000
3000         7000
7000        15000
15000       31000
31000       50000

緑色の *Apply changes* をクリックすると、以下のグラフが表示されます:

image::images/tutorial-visualize-pie-2.png[]

このグラフは、残高の範囲で分類される1000の口座の割合を示しています。
データのもう1つの性質を見たい場合は、buccket aggregationを追加します。
それぞれの残高の範囲を、さらに口座主の年齢でブレイクダウンしてみましょう。

一番下にある *Add sub-buckets* をクリックし、 *Terms* aggregation を選択し、ドロップダウンから *age* フィールドを選択します。
緑色の *Apply changes* ボタンをクリックすると、新しい結果として外側の輪が追加されます。

image::images/tutorial-visualize-pie-3.png[]

検索フィールドの右側にある *Save Visualization* ボタンをクリックして、このグラフを保存しましょう。可視化の名前は _Pie Example_ とします。

次に棒グラフをつくりましょう。
*New Visualization* をクリックし、 *Vertical bar chart* を選択します。
*From a new search* を選択し、 `shakes*` インデックスパターンを選びます。
この時点では、まだbucketを定義していないので、大きな1本の棒が表示されているだけでしょう。

image::images/tutorial-visualize-bar-1.png[]

Y軸のmetric aggregationとして、 *Unique Count* を選択し、フィールドには *speaker* を指定します。
もしあなたの映画会社の俳優が足りていないのであれば、シェイクスピアの脚本において、どの脚本がもっともセリフのある役が少ないのかを知って役立てることができるかもしれません。
X軸のbucketには、 *Terms* を選択し、フィールドに *play_name* を指定します。
*Order* は *Bottom* を選択し *Size* は5のままにします。

他の要素はデフォルトのままとし、緑色の *Apply changes* ボタンをクリックしてください。
グラフは以下のようになるでしょう:

image::images/tutorial-visualize-bar-2.png[]

個々の脚本の名前が、バラバラにされた個別の単語ではなく、全フレーズが表示されていることに気づくでしょう。
これは、チュートリアルの最初に *play_name* フィールドに `not analyzed' というマークを付けたマッピングの結果です。

それぞれのバーにマウスオーバーすると、それぞれの脚本におけるセリフの役のある数がツールチップで表示されます。
Hovering on each bar shows you the number of speaking parts for each play as a tooltip.
左上にある *Options* をクリックして、この挙動を向こうにすることができます。他にもたくさんのオプションを変更することができます。

今や、シェイクスピアの脚本から、もっともキャストが少ない一覧を持っています。
あなたはこれらの脚本において、役のセリフの最大数を示して、個々の俳優へのもっとも高い要求を知ることに興味があるかもしれません。
*Add metrics* ボタンからY軸のaggregationを追加し、 *Max* aggregationを選択して、フィールドには *speec_number* を指定します。
*Options* タブで、 *Bar Mode* のドロップダウンを *grouped* に変更し、緑色の *Apply changes* ボタンをクリックします。
グラフは以下のように表示されます:

image::images/tutorial-visualize-bar-3.png[]

このグラフを見ると _Love's Labours Lost_ が、他の脚本と比較して、普通ではないセリフの最大数を持っていることが分かります。
そしてそれ故に、俳優の記憶力により頼らなければならないことが分かります。

このグラフを _Bar Example_ という名前で保存しておきましょう。

続いて、地理的なデータを可視化するためのタイルマップをつくってみましょう。
*New Visualization* をクリックし *Tile map* を選択します。
*From a new search* を選択し `logstash-*` インデックスパターンを指定します。
Kibanaインタフェースの右上にある時間のセレクタをクリックし、探索するイベントの時間の範囲を定義します。
*Absolute* をクリックし、終了日時を2015年5月20日に、開始日時を2015年5月18日に設定します。

image::images/tutorial-timepicker.png[]

時間の範囲を設定したら *Go* ボタンをクリックし、下にある小さな上向きの矢印をクリックしタイムピッカーを閉じます。
まだ何もbucketを定義していないので、以下のような世界地図が表示されます:

image::images/tutorial-visualize-map-1.png[]

bucketとして、 *Geo Coordinates* を選択し、 緑色の *Apply changes* ボタンをクリックしてください。
次のような図が表示されるでしょう:

image::images/tutorial-visualize-map-2.png[]

クリックやドラッグをおこなうことで、地図の操作をおこなうことができます。
image:images/viz-zoom.png[] のズームボタンか、 *Fit Data Bounds* image:images/viz-fit-bounds.png[] を利用することで、すべての点が含まれるもっとも広いレベルにズームすることができます。
また *Latitude/Longitude Filter* image:images/viz-lat-long-filter.png[] ボタンをクリックして、地図上で四角形を範囲を選択することで、その範囲を含むまたは含まないという条件を指定することのできるフィルターをつくることができます。
検索ボックスのすぐ下にある緑色の楕円形が、そのフィルタの定義を表示しています。

image::images/tutorial-visualize-map-3.png[]

フィルター上にマウスオーバーすると、フィルタのトグル、ピン止め、反転、削除などをおこなうためのコントロールが表示されます。
この図を _Map Example_ という名前で保存しましょう。

最後に、ダッシュボードに表示するためのMarkdownウィジェットのサンプルを定義します。
*New Visualization* をクリックし *Markdown widget* を選択すると、とてもシンプルなMarkdownの入力フィールドが表示されます:

image::images/tutorial-visualize-md-1.png[]

以下のテキストをフィールドに記述しましょう:

[source,markdown]
# This is a tutorial dashboard! 
The Markdown widget uses **markdown** syntax.
> Blockquotes in Markdown use the > character.

緑色の *Apply chagens* ボタンをクリックすると、プレビュー領域に描画されたMarkdownが表示されます:

image::images/tutorial-visualize-md-2.png[]

この可視化を _Markdown Example_ という名前で保存します。

[[tutorial-dashboard]]
=== ダッシュボードに全部一緒に配置しよう

Kibanaのダッシュボードでは、可視化したものを配置してシェアすることができます。
A Kibana dashboard is a collection of visualizations that you can arrange and share.
*Dashboard* タブを開き、検索ボックスの右側の端にある *Add Visualization* をクリックすると、保存した可視化の一覧が表示されます。
_Markdown Example_, _Pie Example_, _Bar Example_, _Map Example_ を選択したら、一覧の下にある小さな上向きの矢印をクリックして可視化の一覧を閉じます。
それぞれの可視化をクリックしてタイトルバーをドラッグすることで、コンテナを移動させることができます。
また、可視化のコンテナの右下隅をドラッグすることで、リサイズすることができます。
サンプルのダッシュボードは、最終的にだいたい以下のようになるでしょう:

image::images/tutorial-dashboard.png[]

*Save Dashboard* ボタンをクリックし _Tutorial Dashboard_ という名前を付けます。
*Share* ボタンをクリックすることで、保存したダッシュボードを、埋め込みHTML、またはリンクをシェアすることができます。

[float]
[[wrapping-up]]
=== Wrapping Up

ここまで、Kibanaの機能の基本的な側面に触れて、Kibanaをより詳細に探索する準備ができました。
より詳細に知りたい場合は残りのドキュメントを見てください!

